import META from './meta.mjs';
import Validator from './validator.mjs';
import ModelError from './model-error.mjs';

import mongo from 'mongodb';

import assert from 'assert';
import util from 'util';


/** 

All detected errors should be reported by throwing an array of
ModelError objects.  

Errors are of two types:

  + *Local errors* depend only on the field values of the current data
    item.  Local errors are specified and checked using meta.mjs
    and validator.mjs and are not specified below.

  + *Global errors* depend on data items other than the current data
    item.  The comments for the code below document global errors.

Each ModelError must be specified with an error code (defined below)
and an error message which should be as specific as possible.  If the
error is associated with a particular field, then the internal name of
that field should be filled in to the ModelError object.  Note that if
an error message refers to the name of the field, it should do so
using the external name (`label`) of the field.

The codes for the ModelError include the following:

BAD_ACT:
  Action does not correspond to one of the model action routines.

BAD_FIELD:
  An object contains an unknown field name or a forbidden field.

BAD_FIELD_VALUE:
  The value of a field does not meet its specs.

BAD_ID:
  Object not found for specified ID.  Includes an error when some field 
  specifies an id for some other object, but there is no object having
  that ID.

DB:
  Database error

FORM_ERROR:
  Form is invalid.

MISSING_FIELD:
  The value of a required field is not specified.

*/

export default class Model {

  /** Set up properties from props as properties of this. */
  constructor(props) {
    Object.assign(this, props);
  }

  /** Return a new instance of Model set up to use database specified
   *  by dbUrl
   */ 
  static async make(dbUrl) {
    let client, db, user1, user2;
    try {
      //@TODO
      //client = await mongo.connect(MONGO_URL, MONGO_CONNECT_OPTIONS);
      //client = await mongo.connect(dbUrl, MONGO_CONNECT_OPTIONS);
      /*db = client.db('books');
      user1= db.collection(BOOK_TABLE);
      user2= db.collection(CART_TABLE);
      db.collection('sample').insertOne({'key':10}, function(){
      	console.log("inserted doc success");
      });*/
      
		var regex = RegExp('^(mongodb:(?:\/{2})?)((\w+?):(\w+?)@|:?@?)(\w+?)(:(\d+))?\/(\w+?)$');
		if( regex.test(dbUrl) || 1 ) {
			let MONGO_URL = dbUrl.substring(0, dbUrl.lastIndexOf("/"));
			client = await mongo.connect(MONGO_URL, MONGO_CONNECT_OPTIONS);

			let split_array = dbUrl.split('/');
			let DB_NAME = split_array[split_array.length-1];
			db = client.db(DB_NAME, { useUnifiedTopology: true });
		} else {
			const msg = `Connection URL is invalid.`;
			throw [ new ModelError('DB', msg) ];
		}
      
		this.client = client;
		this.db = db;
		for (const k of COLLECTIONS) {
			this[k] = this.db.collection(k);
		}
      //console.log(users);
      const props = {
		validator: new Validator(META),
		client: this.client,
		db: this.db,
		//user1: user1,
		//user2: user2,
		//users: users
		//@TODO other properties
      };

      const model = new Model(props);
      return model;
    }
    catch (err) {
		const msg = `Database error "${dbUrl}": ${err}`;
		throw [ new ModelError('DB', msg) ];
    }
  }
  
 
  /** Release all resources held by this model.  Specifically,
   *  close any database connections.
   */
  async close() {
    //@TODO
    try {
		await this.client.close();
    }
    catch (err) {
		const msg = `Database error "${dbUrl}": ${err}`;   
		throw new ModelError('DB', msg);
    }
  }

  /** Clear out all data stored within this model. */
  async clear(dbUrl) {
    //@TODO
    try{
   		//await this.db.collection(BOOK_TABLE).drop();
    	//await this.db.collection(CART_TABLE).drop();
    	//await this.user1.drop();
    	//await this.user2.drop();
    	for (const k of COLLECTIONS) {
			// await this[k].deleteMany({});
			await this.db.collection(k).deleteMany({});
		}
    	//await this.db.collection('sample').drop();
    	//await this.db.dropDatabase();
    }
    catch (err) {
   		const msg = `Database error "${dbUrl}": ${err}`;   
   		throw new ModelError('DB', msg);
    } 
  }
  
  //Action routines

  /** Create a new cart.  Returns ID of newly created cart.  The
   * returned ID should not be generated by the database; it should
   * also not be easily guessable.
   *
   *  The new cart should have a `_lastModified` field set to the
   *  current Date timestamp.
   */
  
  async newCart(rawNameValues) {
    const nameValues = this._validate('newCart', rawNameValues);
    const sc_collection = await this.db.collection( 'shoppingCart' );
    const count = await sc_collection.countDocuments({ });
    //console.log(count);
    //nameValues['cartId'] = 'cart_' + (parseInt(Math.random() * 1000000000)) + count;
	const ret = await sc_collection.insertOne({_id:Math.random(), _lastModified: new Date().toISOString()});

	return ret.insertedId;
    //@TODO
  }

  /** Given fields { cartId, sku, nUnits } = rawNameValues, update
   *  number of units for sku to nUnits.  Update `_lastModified` field
   *  of cart to current Date timestamp.
   *
   *  Global Errors:
   *    BAD_ID: cartId does not reference a cart.
   *            sku does not specify the isbn of an existing book.
   */
  async cartItem(rawNameValues) {
    const nameValues = this._validate('cartItem', rawNameValues);
    
    const val = await this.findBooks({isbn:nameValues.sku });
    if(val.length <= 0) {
	    const msg = `${nameValues.sku} SKU does not specify the isbn of an existing book.`;   
		throw new ModelError('BAD_ID', msg);
    }
    const sc_collection = await this.db.collection( 'shoppingCart' );
    let updateResult = "";
	if(nameValues.nUnits === 0){
		updateResult = await sc_collection.updateOne(
		   { _id: +(nameValues.cartId) },
		   { 
		   	$currentDate: {
			"_lastModified": true,
		 	},
		 	$set:
			  {
				"nUnits" : nameValues.nUnits
			  },
			$unset:
			  {
				"sku" : ""
			  }
			},
			{upsert: true}
		);
	} else {
		updateResult = await sc_collection.updateOne(
		   { _id: +(nameValues.cartId) },
		   {
		   	$currentDate: {
			"_lastModified": true,
		 	},
			$set:
			  {
				"sku" : nameValues.sku,
				"nUnits" : nameValues.nUnits,
			  }
			},
			{upsert: true}
		);
	}

	if(updateResult.matchedCount < 1  ) {
		const msg = `no updates for cart : ${nameValues.cartId} `;   
		throw new ModelError('BAD_ID', msg);
	}
  }
  
  /** Given fields { cartId } = nameValues, return cart identified by
   *  cartId.  The cart is returned as an object which contains a
   *  mapping from SKU's to *positive* integers (representing the
   *  number of units of the item identified by the SKU contained in
   *  the cart).  Addtionally, it must also have a `_lastModified`
   *  property containing a Date timestamp specifying the last time the
   *  cart was modified.
   *
   *  Globals Errors:
   *    BAD_ID: cartId does not reference a cart.
   */
  async getCart(rawNameValues) {
    try {
		const nameValues = this._validate('getCart', rawNameValues);
	   	const sc_collection = await this.db.collection( 'shoppingCart' );
	   	
	   	const ret =  await sc_collection.findOne( { _id : +(nameValues.cartId) } );
	   	
	   	if(ret === null ){
			const msg = `unknown sku : ${ret.sku} `;   
			throw new ModelError('BAD_ID', msg);
		}
	   	const key2 = ret.sku;
	   	let res = {};
	   	if(ret.nUnits > 0) {
	   		res = {"_lastModified" : ret._lastModified, 
			[key2] : ret.nUnits
		};
		} else {
			res = {"_lastModified" : ret._lastModified };
		} 

		return res;
   	} catch(err){ }
    //@TODO
  	}

  /** Given fields { isbn, title, authors, publisher, year, pages } =
   *  nameValues for a book, add the book to this model.  The isbn
   *  field should uniquely identify the book.  Note that if the book
   *  already exists in this model, then this routine should merely
   *  update the information associated with the book.
   *
   *  Returns the isbn of the added/updated book.
   *
   *  This routine should set a `_lastModified` field in the book to
   *  the current Date timestamp.
   */
  async addBook(rawNameValues) {
    const nameValues = this._validate('addBook', rawNameValues);
    //console.log(nameValues);
	try {
		const bc_collection = await this.db.collection( 'bookCatalog' );
		const ret = await bc_collection.updateOne(
			 { isbn : nameValues.isbn },
			 { 
			   	$currentDate: {
				"_lastModified": true,
			 	},
				$set: nameValues
				},
			 {"upsert" : true}
		);
		return nameValues.isbn;
	} catch (err) {
	
	}
    //@TODO
  }

  /** Given fields { isbn, authorsTitle, _count=COUNT, _index=0 } =
   *  nameValues, retrieve list of all books with specified isbn (if
   *  any) and the words specified in authorsTitle occurring in either
   *  the book's authors field or the title field.  The retrieved
   *  results are sorted in ascending order by title.  The returned
   *  results have up to _count books starting at index _index in the
   *  retrieved results.  The `_index` and `_count` fields allow
   *  paging through the search results.
   *
   *  Will return [] if no books match the search criteria.
   */
  async findBooks(rawNameValues) {
    const nameValues = this._validate('findBooks', rawNameValues);
    let ret,res;
    const bc_collection = await this.db.collection( 'bookCatalog' );
    
    bc_collection.createIndex({authors: "text", title: "text"});

    if(nameValues.isbn && nameValues.authorsTitleSearch === undefined ) {
    	ret = await bc_collection.find( { "isbn" : nameValues.isbn } ) ;
    } else {
    	ret = await bc_collection.find({
    		$text: {$search : nameValues.authorsTitleSearch}
    	});
    }
    
    /* else if(nameValues.isbn === undefined && nameValues.authorsTitleSearch) {
    	ret = await bc_collection.find({
    		$or: [
    			{ "title" : {'$regex': nameValues.authorsTitleSearch, '$options' : 'i' } },
    			{ "authors": {'$regex': nameValues.authorsTitleSearch, '$options' : 'i' } }
    		]
    	});
    } else {
     	ret = await bc_collection.find({
     		$or: [
     			{ "isbn" : nameValues.isbn },
     			{ "title" : {'$regex': nameValues.authorsTitleSearch, '$options' : 'i' } },
     			{ "authors": {'$regex': nameValues.authorsTitleSearch, '$options' : 'i' } }
     		]
     	});
    }*/

    /*if(nameValues._count && nameValues._index === undefined) {
    	res = await ret.sort({title : 1}).limit( nameValues._count ).toArray();
    } else if(nameValues._count === undefined && nameValues._index) {
    	res = await ret.sort({title : 1}).skip( nameValues._count > 0  ? ( ( nameValues._index - 1 ) * nameValues._count ) : 0 ).limit( nameValues._count ).toArray();
    } else {
    	res = await ret.sort({title : 1}).toArray();
    }*/

    let limit = nameValues._count !== undefined ? nameValues._count : COUNT;
    res = await ret.sort({title : 1}).skip( nameValues._count > 0  ? ( ( nameValues._index - 1 ) * nameValues._count ) : 0 ).limit( limit ).toArray();
    
    if(res.length > 0) {
    	return res;
    } else {
    	 return [];
    }
             
    //@TODO
   
  }
  
  
  //wrapper around this.validator to verify that no external field
  //is _id which is used by mongo
  _validate(action, rawNameValues) {
    let errs = [];
    let nameValues;
    try {
      nameValues = this.validator.validate(action, rawNameValues);
    }
    catch (err) {
      if (err instanceof Array) { //something we understand
	errs = err;
      }
      else {
	throw err; //not expected, throw upstairs
      }
    }
    if (rawNameValues._id !== undefined) {
      errs.push(new ModelError('BAD_FIELD', '_id field not permitted', '_id'));
    }
    if (errs.length > 0) throw errs;
    return nameValues;
  }
  
  
};

//use as second argument to mongo.connect()
const MONGO_CONNECT_OPTIONS = { useUnifiedTopology: true };

//default value for _count in findBooks()
const COUNT = 5;

//define private constants and functions here.
//const table = `_json= HOME/cs544/data/book.json `;
//let BOOK_TABLE='book';
//let CART_TABLE = 'cart';
const COLLECTIONS = [
	"bookCatalog",
	"shoppingCart"
];
  

